-------------------------------------------------------------SQL QUERY PRACTICE---------------------------------------------------------
--Q1.Find the second highest salary from employees.
select distinct salary from employees order by salary desc offset 1 rows fetch next 1 rows only;
select max(salary) maxsal from employees where salary<(select max(salary) from employees);
select max(salary) maxsal from employees where salary not in (select max(salary) from employees);

--Q2.Display the highest paid employees from each department.
select max(salary) highest_paid_employees,department_id from employees group by department_id order by DEPARTMENT_ID;

--Q3.Display the lowest paid employees from each department.
select min(salary) highest_paid_employees,department_id from employees group by department_id order by DEPARTMENT_ID;

--Q4.Display the number of employees in each department.
select count(1) no_of_employees,department_id from employees group by department_id order by DEPARTMENT_ID;

--Q5.Write a query to find out duplicate records.
select col1,col2,count(1) from employees group by col1,col2 having count(1)>1; 
select * from (select rowid rn,row_number() over (partition by salary order by salary) duplicate from employees) where duplicate>1;

--Q6.Write a query to delete duplicate records.
delete from emp1 where rowid in (
select rn from (select rowid as rn,row_number() OVER (Partition by salary ORDER BY salary) AS drank from emp1) where drank>1);

delete from table_name where rowid in (
select rn from (select rowid rn,row_number() over (partition by salary order by salary) duplicate from employees) where duplicate>1);

--Q7.Get top 3 salaries per department.
select * from (
select salary,department_id,row_number() over (partition by department_id order by salary desc) rank 
from employees group by salary,DEPARTMENT_ID) where rank<=3;

--Q8.Find employees who are hired on weekends.
select * from employees where trim(to_char(hire_date, 'day')) in ('saturday','sunday');

--Q9.rank employee by salary within each department.
select department_id,salary,rank() over (partition by department_id order by salary) rank from employees;

--Q10.Identify top performing departments by avg salary.
select avg(salary) avgsal,department_id from employees group by department_id order by avgsal desc;

--Q11.Find the percentage of employees in each departments.
select department_id,count(1)/(select count(1) from employees)*100 from employees group by department_id;

--Q12.Retrive the maximum salary difference within each department.
select DEPARTMENT_ID,max(salary)-min(salary) maxsaldiff from employees group by department_id;

--Q13.Find employees with salary higher than department average.
select * from employees e where salary>(select avgsal from(select DEPARTMENT_ID,avg(salary) avgsal from employees group by department_id)d where e.department_id=d.department_id);

with cte as (
select department_id,round(avg(salary)) avgsalary from employees group by department_id)
select * from cte join employees e on cte.department_id=e.department_id where e.salary>cte.avgsalary;

--Q14.Swap valus of column.
select EMP_ID,DEPARTMENT,case emp_id when 1 then (select DEPARTMENT from empdup where EMP_ID=4) when 4 then (select DEPARTMENT from empdup where EMP_ID=1 ) else department end from empdup;

MERGE INTO empdup e
USING (SELECT emp_id,CASE emp_id WHEN 1 THEN (SELECT department FROM empdup WHERE emp_id = 4) WHEN 4 THEN (SELECT department FROM empdup WHERE emp_id = 1)END AS new_dept
FROM empdup WHERE emp_id IN (1, 4)) src ON (e.emp_id = src.emp_id) WHEN MATCHED THEN UPDATE SET e.department = src.new_dept;

--Q15.Write a query to find who is getting more than there manager.
select * from employees e,employees m where e.MANAGER_ID=m.EMPLOYEE_ID and e.SALARY>m.SALARY;

SELECT e.employee_id AS employee_id,e.first_name AS employee_name,e.manager_id AS manager_id,m.first_name AS manager_name,m.department_id AS manager_department
FROM employees e LEFT JOIN employees m ON e.manager_id = m.employee_id where e.salary>m.salary;

--Q16.Find employees who are managers
select distinct m.FIRST_NAME from employees e,employees m where e.MANAGER_ID=m.EMPLOYEE_ID ;

SELECT DISTINCT m.employee_id,m.first_name AS manager_name
FROM employees e JOIN employees m ON e.manager_id = m.employee_id;

--Q17.Find employees who are not managers
select distinct m.FIRST_NAME from employees e,employees m where e.MANAGER_ID<>m.EMPLOYEE_ID ;

--Q18.List employees along with their manager’s name.
select distinct e.FIRST_NAME,m.FIRST_NAME from employees e,employees m where e.MANAGER_ID=m.EMPLOYEE_ID ;

--Q19.Count how many employees each manager has
select distinct m.FIRST_NAME manager_name,count(1) empcount from employees e,employees m where e.MANAGER_ID=m.EMPLOYEE_ID group by m.FIRST_NAME;

--Q20.Find managers who manage more than 5 employees
select m.FIRST_NAME,count(1) from employees e,employees m where e.MANAGER_ID=m.EMPLOYEE_ID group by m.FIRST_NAME having count(1)>5;

--Q21.Find all employees in the same department as their manager
select e.FIRST_NAME from employees e,employees m where e.MANAGER_ID=m.EMPLOYEE_ID and e.department_id=m.department_id;

SELECT e.first_name,e.manager_id,e.department_id,m.first_name,m.department_id
FROM employees e JOIN employees m ON e.manager_id = m.employee_id where e.department_id=m.department_id;


--Q22.Find employees who have the same salary as their manager
select e.FIRST_NAME from employees e,employees m where e.MANAGER_ID=m.EMPLOYEE_ID and e.salary=m.salary;

--Q23.Get the top 3 managers who have the highest total salary among their subordinates
select distinct m.EMPLOYEE_ID,m.fIRST_NAME,sum(e.salary) total_team_salary from employees e,employees m where e.MANAGER_ID=m.EMPLOYEE_ID 
group by m.EMPLOYEE_ID,m.fIRST_NAME ORDER BY total_team_salary DESC FETCH FIRST 3 ROWS ONLY; 

--Q24.Find the highest-paid employee under each manager
select * from (
select e.FIRST_NAME employee,e.salary,m.FIRST_NAME manager,dense_rank() over (partition by m.FIRST_NAME order by e.salary desc) rn
from employees e,employees m where e.MANAGER_ID=m.EMPLOYEE_ID) where rn=1;

SELECT e.manager_id,m.first_name AS manager_name,e.employee_id,e.first_name AS employee_name,e.salary
FROM employees e JOIN employees m ON e.manager_id = m.employee_id
WHERE (e.manager_id, e.salary) IN (SELECT manager_id,MAX(salary)FROM employees GROUP BY manager_id);

--Q25.Find employees who joined in the last 6 months. (Imp)
select * from employees where to_char(hire_date, 'mon')  between 'january' and 'june';
SELECT * FROM EMPLOYEES WHERE HIRE_DATE >= ADD_MONTHS(SYSDATE, -6);

--Q26.Display the department wise total and avg salary
select department_id,avg(salary),sum(salary) from employees group by department_id;

--Q27.Get employee names in hierarchical order (manager → employee)
SELECT LEVEL, EMPLOYEE_ID, FIRST_NAME, MANAGER_ID FROM EMPLOYEES
START WITH MANAGER_ID IS NULL CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID;

--Q28.Display nth row in sql
select e.*,row_number() over (order by EMPLOYEE_ID) nth from employees e;

--Q29.Display the employee details who join before their manager.
select * from employees e,employees m where e.MANAGER_ID=m.EMPLOYEE_ID and e.HIRE_DATE<m.HIRE_DATE;

--30.Write a SQL query to display each employee's employee_id, salary, and a running_total column that shows the cumulative sum of salaries ordered by employee_id.
select employee_id,salary,sum(salary) over (order by EMPLOYEE_ID) cumsalary from employees;

--31.Write a SQL query to display each employee's employee_id, department_id, salary, and the cummulative salary of their department using a window function.
select employee_id,DEPARTMENT_ID,salary,sum(salary) over (partition by department_id order by salary) cummulative_salary from employees group by EMPLOYEE_ID,DEPARTMENT_ID,SALARY;

--32.Average Salary by Department using window function
select department_id,avg(salary) over (partition by department_id) avgsalary from employees;

--33.Maximum Salary per Department using window function
SELECT employee_id,department_id,salary,MAX(salary) OVER (PARTITION BY department_id) AS max_salary_in_dept FROM employees;

--34.Count of Employees per Department using window function
SELECT department_id,count(1) OVER (PARTITION BY department_id) AS employeecount FROM employees;

--35.Display first and last row of employee table.
SELECT *
FROM (
        SELECT e.*, ROW_NUMBER() OVER (ORDER BY department_id) rn
        FROM employees e
        ORDER BY rn
    )
WHERE ROWNUM = 1
UNION
SELECT *
FROM (
        SELECT e.*, ROW_NUMBER() OVER (ORDER BY department_id) rn
        FROM employees e
        ORDER BY rn DESC
    )
WHERE ROWNUM = 1;

select * from (select rownum r,e.* from employees e) where r=1 or r=(select count(1) from employees);

--36.Display the details of lowest and highest salary in a table.
select * from employees where salary=(select min(salary) from employees) or salary=(select max(salary) from employees);

--37.Display the last two rows of the table
select ROWNUM rn,e.* from employees e order by rn desc fetch next 2 rows only;

select * from employees
minus
select * from employees where rownum<=(select count(1)-2 from employees);

--38.Display the first and last two rows of the table.
SELECT *
FROM (
    SELECT e.*, ROW_NUMBER() OVER (ORDER BY employee_id) rn
    FROM employees e
)
WHERE rn <= 2
UNION ALL
SELECT *
FROM (
    SELECT e.*, ROW_NUMBER() OVER (ORDER BY employee_id DESC) rn
    FROM employees e
)
WHERE rn <= 2;

select * from (select rownum r,e.* from employees e) where r>(select count(1)-2 from employees) or r in (1,2); 

--39.How to fetch  monthly Salary of Employee if annual salary is given?
select 10000/12 from dual;

--40.Display first 50% records from Employee table.
select * from (select e.*,rownum rn from employees e) where rn<=(select count(1)/2 from employees);

--41.Display last 50% records from Employee table?
select * from (select e.*,rownum rn from employees e) where rn>=(select count(1)/2 from employees);

--42.how to write sql query for the below scenario
/*
O
R
A
C
L
E
*/
Select Substr('ORACLE',Level,1) From Dual
Connect By Level<= Length('ORACLE');
--`Connect By uses for hierarchical/tree data
-- LEVEL is an Oracle pseudo-column that automatically numbers these rows.

--42.How to add the email validation using only one query?
SELECT
Email
FROM
Employees
where NOT REGEXP_LIKE(Email, '[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}', 'i');

--43.How to display 1 to 100 Numbers with query?
Select level from dual connect by level <=100;

--44.How to dupliacte employee table?
create table emp_dup as select * from employees;

--45.How to duplicate employee table without using create table statement.
set SERVEROUTPUT on;
declare 
v_dup varchar2(100);
BEGIN
    v_dup:='Create table emp_dup as select * from employees';
     execute immediate v_dup;
end;



