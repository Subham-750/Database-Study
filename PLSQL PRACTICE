--------------------------------------------------------------PLSQL Practice--------------------------------------------------------------
/*--------------------------------------------------Q1 Started---------------------------------------------------------- 
Difference between Delete and truncate proving some points.
•	Delete is a DML command and truncate is a DDL command where DML commands are not auto committed and DDL commands are auto committed.
•	We can use where condition in delete but in truncate where condition is not allowed.
•	Delete is slower compared to truncate since deleted records are stored in undo table space for rollback and 
    truncate is faster cause it doesn’t keeps the data in undo table space.
•	Triggers will get fired while applying delete. Triggers will not get fired in truncate.
•	Delete won’t reclaim the space because it moves the data into undo table space for rollback and truncate reclaim the space instantly.
•	Delete won’t reset high level of watermark even if commit applied explicitly, but truncate reset high level of water mark instantly.
•	From 12c onwards we can use “on delete cascade” in the child table for deletion of data from both parent and child table 
    likewise in truncate we can able to truncate data from parent and child table at once applying “truncate table tb_name cascade”.

Note: When we apply delete on parent table why data gets deleted from child table? 
      But in the same way when we apply delete on the child table data only gets deleted from the child table not from the parent table why? 
      Same applies to truncate also.
      • It is because data flows from parent to child not from child to parent.

      What if I want to delete the records and get faster response to load in the table, is there any way?
      • Yes, there is a way, we can create a backup of that table and apply truncate then we can load the data as per our need without applying delete directly instead we can filter out the records through query and load the data in the table.
*/

--Pont1:Triggers will get fired while applying delete. Triggers will not get fired in truncate. To Prove this below is the code

--Loop to insert some records in table
set SERVEROUTPUT on;
declare 
v_count number;
BEGIN
    for v_count in 1..10
    loop
    insert into tb1 values(v_count);
    end loop;
end;    

--This raise the error if we execute delete command
create or replace trigger tr_delete
before delete on tb1 for EACH ROW
BEGIN
    raise_application_error(-20000,'Trigger is fired');
end;

--When we execute delete the trigger got raise hence its prove that trigger gets fire when we execute delete
delete from tb1;

--Trigger doesnt fire hence its prove that truncate doesnt raise trigger
TRUNCATE TABLE tb1;

--Point2: Delete is slower as compaired to truncate and delete contains watermark but truncate doesnt lets prove this
--I have created this table for test
create table delete_truncate_slow_test
(
    function_name VARCHAR2(100),
    Apply_status VARCHAR2(100)
); 

--I check the size of the table which is 0.0 MB
SELECT segment_name , bytes/1024/1024 AS size_mb
FROM user_segments
WHERE segment_name = 'DELETE_TRUNCATE_SLOW_TEST';

--Inserted 8 million records in table
INSERT into delete_truncate_slow_test select 'Delete','Yes' from dual connect by level<=1000000;

-- Check the size of the table which is 143 MB
SELECT segment_name , bytes/1024/1024 AS size_mb
FROM user_segments
WHERE segment_name = 'DELETE_TRUNCATE_SLOW_TEST';

/*Now i applied delete which took me 5 sec move the records from original table to undo space and commit but 
still i can see the table space which is still showing 143 MB that means it contains the watermark also*/
delete from delete_truncate_slow_test;

/*I applied Truncate after delete which takes 0.3 seconds which is faster than delete and also 
it removes the watermark, means it recliam the space that is used by table.*/
truncate table DELETE_TRUNCATE_SLOW_TEST;

--Point3: Proving how truncate table tb_name cascade works
--First i created Two table and inserted data
CREATE TABLE CHILD_TABLE  ("CHILD_ID" NUMBER,"PARENT_ID" NUMBER,"DESCRIPTION" VARCHAR2(100), 
CONSTRAINT "FK_CHILD" FOREIGN KEY ("CHILD_ID") REFERENCES "PARENT_TABLE" ("PARENT_ID") ON DELETE CASCADE ENABLE );
INSERT INTO CHILD_TABLE (CHILD_ID, PARENT_ID, DESCRIPTION) VALUES (101, 101, 'Root Category');
INSERT INTO CHILD_TABLE (CHILD_ID, PARENT_ID, DESCRIPTION) VALUES (102, 102, 'Sub Category A');
INSERT INTO CHILD_TABLE (CHILD_ID, PARENT_ID, DESCRIPTION) VALUES (103, 103, 'Sub Category B');
INSERT INTO CHILD_TABLE (CHILD_ID, PARENT_ID, DESCRIPTION) VALUES (104, 104, 'Sub Category A1');
INSERT INTO CHILD_TABLE (CHILD_ID, PARENT_ID, DESCRIPTION) VALUES (105, 105, 'Sub Category A2');
INSERT INTO CHILD_TABLE (CHILD_ID, PARENT_ID, DESCRIPTION) VALUES (106, 106, 'Sub Category B1');
INSERT INTO CHILD_TABLE (CHILD_ID, PARENT_ID, DESCRIPTION) VALUES (107, 107, 'Sub Category B2');

CREATE TABLE PARENT_TABLE("PARENT_ID" NUMBER,"NAME" VARCHAR2(50),PRIMARY KEY ("PARENT_ID"));
INSERT INTO PARENT_TABLE (PARENT_ID, NAME) VALUES (101, 'Item 1');
INSERT INTO PARENT_TABLE (PARENT_ID, NAME) VALUES (102, 'Item 2');
INSERT INTO PARENT_TABLE (PARENT_ID, NAME) VALUES (103, 'Item 3');
INSERT INTO PARENT_TABLE (PARENT_ID, NAME) VALUES (104, 'Item 4');
INSERT INTO PARENT_TABLE (PARENT_ID, NAME) VALUES (105, 'Item 5');
INSERT INTO PARENT_TABLE (PARENT_ID, NAME) VALUES (106, 'Item 6');
INSERT INTO PARENT_TABLE (PARENT_ID, NAME) VALUES (107, 'Item 7');

/*In this parent table if i apply delete command on parent table the asociated data in child table will get deleted
in the same way if i apply truncate table tb_name cascade then it will truncate both of the table*/
truncate table PARENT_TABLE cascade;
------------------------------------------------------------Q1 End-------------------------------------------------------------------

/*Q2.Difference between procedure and function*/
--Point1: We use out parameter in procedure to return a value and inside a function we use return keyword to return a value.



